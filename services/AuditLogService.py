"""
AuditLogService.py
------------------
Business logic for audit log operations and activity tracking.
"""

from __future__ import annotations
from datetime import datetime
from typing import Optional, Tuple, List, Literal, Any
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, func
from models.AuditLogModel import AuditLog, EntityType, ChangeType


class AuditLogService:
    """Service for managing audit log operations."""

    def __init__(self, db: Session):
        self.db = db

    def create_audit_log(
        self,
        *,
        entity_type: EntityType,
        entity_id: UUID,
        change_type: ChangeType,
        previous_state: Optional[dict[str, Any]] = None,
        new_state: Optional[dict[str, Any]] = None,
        changed_by_user_id: Optional[UUID] = None,
    ) -> AuditLog:
        """
        Create (enqueue) an audit log row in the current transaction.
        - NO COMMIT here. Router decides when to commit/rollback.
        - ID is auto-generated by BaseModel default
        """
        row = AuditLog(
            entity_type=entity_type,
            entity_id=entity_id,
            change_type=change_type,
            previous_state=previous_state,
            new_state=new_state,
            changed_by_user_id=changed_by_user_id,
        )
        self.db.add(row)
        return row

    def get_audit_log(self, log_id: UUID) -> Optional[AuditLog]:
        """
        Retrieve a single audit log by ID.
        Returns None if not found.
        """
        return self.db.execute(
            select(AuditLog).where(AuditLog.id == log_id)
        ).scalar_one_or_none()

    def list_audit_logs(
        self,
        *,
        entity_type: Optional[EntityType] = None,
        entity_id: Optional[UUID] = None,
        change_type: Optional[ChangeType] = None,
        changed_by_user_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        limit: int = 25,
        offset: int = 0,
        order: Literal["asc", "desc"] = "desc",
    ) -> Tuple[List[AuditLog], int]:
        """
        List audit logs with optional filters and pagination.

        Utilizes indexes:
        - idx_audit_entity (entity_type, entity_id)
        - changed_by_user_id index
        - created_at for ordering
        """
        # ---- build shared filters once ----
        filters = []
        if entity_type:
            filters.append(AuditLog.entity_type == entity_type)
        if entity_id:
            filters.append(AuditLog.entity_id == entity_id)
        if change_type:
            filters.append(AuditLog.change_type == change_type)
        if changed_by_user_id:
            filters.append(AuditLog.changed_by_user_id == changed_by_user_id)
        if date_from:
            filters.append(AuditLog.created_at >= date_from)
        if date_to:
            filters.append(AuditLog.created_at < date_to)  # half-open range

        # ---- total count (optimized) ----
        count_query = select(func.count(AuditLog.id)).select_from(AuditLog)
        if filters:
            count_query = count_query.where(*filters)
        total = self.db.execute(count_query).scalar_one()

        # ---- base query ----
        q = select(AuditLog)
        if filters:
            q = q.where(*filters)

        # ---- ordering ----
        if order == "asc":
            q = q.order_by(AuditLog.created_at.asc(), AuditLog.id.asc())
        else:
            q = q.order_by(AuditLog.created_at.desc(), AuditLog.id.desc())

        # ---- paging ----
        q = q.limit(limit).offset(offset)

        items = self.db.execute(q).scalars().all()
        return items, total
