"""
AuditLogService.py
------------------
Business logic for audit log operations and activity tracking.
"""

from __future__ import annotations
from datetime import datetime
from typing import Optional, Tuple, List, Literal, Any
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, func
from models.AuditLogModel import AuditLog, EntityType, ChangeType


class AuditLogService:
    """Service for managing audit log operations."""

    def __init__(self, db: Session):
        self.db = db

    def create_audit_log(
        self,
        *,
        entity_type: EntityType,
        entity_id: UUID,
        change_type: ChangeType,
        previous_state: Optional[dict[str, Any]] = None,
        new_state: Optional[dict[str, Any]] = None,
        changed_by_user_id: Optional[UUID] = None,
    ) -> AuditLog:
        """
        Create (enqueue) an audit log row in the current transaction.
        - NO COMMIT here. Router decides when to commit/rollback.
        - ID is auto-generated by BaseModel default
        """
        row = AuditLog(
            entity_type=entity_type,
            entity_id=entity_id,
            change_type=change_type,
            previous_state=previous_state,
            new_state=new_state,
            changed_by_user_id=changed_by_user_id,
        )
        self.db.add(row)
        return row

    def bulk_create_audit_logs(
        self,
        *,
        entity_type: EntityType,
        entity_ids: List[UUID],
        change_type: ChangeType,
        previous_state: Optional[dict[str, Any]] = None,
        new_state: Optional[dict[str, Any]] = None,
        changed_by_user_id: Optional[UUID] = None,
    ) -> List[AuditLog]:
        """
        Bulk create audit logs for multiple entities with identical fields.

        This is more efficient than calling create_audit_log in a loop as it:
        - Creates all objects in memory first
        - Adds them to the session in bulk using add_all()
        - Reduces database round-trips

        Does NOT commit - router is responsible for transaction management.

        Args:
            entity_type: The type of entities being logged
            entity_ids: List of entity IDs to create audit logs for
            change_type: The type of change (CREATE, UPDATE, DELETE)
            previous_state: Previous state dict (same for all logs)
            new_state: New state dict (same for all logs)
            changed_by_user_id: User who made the change

        Returns:
            List of created AuditLog objects
        """
        if not entity_ids:
            return []

        # Create all audit log objects in memory
        audit_logs = [
            AuditLog(
                entity_type=entity_type,
                entity_id=entity_id,
                change_type=change_type,
                previous_state=previous_state,
                new_state=new_state,
                changed_by_user_id=changed_by_user_id,
            )
            for entity_id in entity_ids
        ]

        # Bulk add all objects to the session
        self.db.add_all(audit_logs)

        return audit_logs

    def get_audit_log(self, log_id: UUID) -> Optional[AuditLog]:
        """
        Retrieve a single audit log by ID.
        Returns None if not found.
        """
        return self.db.execute(
            select(AuditLog).where(AuditLog.id == log_id)
        ).scalar_one_or_none()

    def list_audit_logs(
        self,
        *,
        entity_type: Optional[EntityType] = None,
        entity_id: Optional[UUID] = None,
        change_type: Optional[ChangeType] = None,
        changed_by_user_id: Optional[UUID] = None,
        date_from: Optional[datetime] = None,
        date_to: Optional[datetime] = None,
        limit: int = 25,
        offset: int = 0,
        order: Literal["asc", "desc"] = "desc",
    ) -> Tuple[List[AuditLog], int]:
        """
        List audit logs with optional filters and pagination.

        Utilizes indexes:
        - idx_audit_entity (entity_type, entity_id)
        - changed_by_user_id index
        - created_at for ordering
        """
        # ---- build shared filters once ----
        filters = []
        if entity_type:
            filters.append(AuditLog.entity_type == entity_type)
        if entity_id:
            filters.append(AuditLog.entity_id == entity_id)
        if change_type:
            filters.append(AuditLog.change_type == change_type)
        if changed_by_user_id:
            filters.append(AuditLog.changed_by_user_id == changed_by_user_id)
        if date_from:
            filters.append(AuditLog.created_at >= date_from)
        if date_to:
            filters.append(AuditLog.created_at < date_to)  # half-open range

        # ---- total count (optimized) ----
        count_query = select(func.count(AuditLog.id)).select_from(AuditLog)
        if filters:
            count_query = count_query.where(*filters)
        total = self.db.execute(count_query).scalar_one()

        # ---- base query ----
        q = select(AuditLog)
        if filters:
            q = q.where(*filters)

        # ---- ordering ----
        if order == "asc":
            q = q.order_by(AuditLog.created_at.asc(), AuditLog.id.asc())
        else:
            q = q.order_by(AuditLog.created_at.desc(), AuditLog.id.desc())

        # ---- paging ----
        q = q.limit(limit).offset(offset)

        items = self.db.execute(q).scalars().all()
        return items, total
